package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/redis/go-redis/v9"
)

// --- Configuration ---
const (
	redisAddr         = "localhost:6379"
	groupName         = "group-name"
	streamKey         = "main-stream"
	lastIDConsumerKey = "0-0"

	// A unique name for this checker process
	checkerConsumerName = "checker-consumer-1"
)

func main() {
	rootCtx := context.Background()

	// Connect to Redis
	rdb := redis.NewClient(&redis.Options{
		Addr:     redisAddr,
		Password: "", // no password set
		DB:       0,  // use default DB
	})

	// Ping to check the connection
	if _, err := rdb.Ping(rootCtx).Result(); err != nil {
		log.Fatalf("could not connect to Redis: %v", err)
	}
	log.Println("connected to Redis")

	// For this example, let's ensure the group exists.
	// In a real app, your main consumers would have already created this.
	// The '0-0' means start from the beginning. '$' means start from new messages.
	// We ignore the error because the group might already exist, which is fine.
	_ = rdb.XGroupCreateMkStream(rootCtx, streamKey, groupName, lastIDConsumerKey).Err()

	// Create a ticker that fires every 5 seconds
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	log.Printf("Starting pending message checker for group '%s' on stream '%s'...\n", groupName, streamKey)

	// Loop indefinitely, running on each tick
	for range ticker.C {
		fmt.Println("---------------------------------")
		log.Println("Checking for pending messages...")

		checkAndProcessPending(rootCtx, rdb)
	}
}

func checkAndProcessPending(ctx context.Context, rdb *redis.Client) {
	// 1. Check for pending messages using XPendingExt.
	// We want a detailed list of pending messages, so we provide a start and end.
	// '-' and '+' are special IDs meaning the smallest and largest possible IDs.
	pendingResult, err := rdb.XPendingExt(ctx, &redis.XPendingExtArgs{
		Stream: streamKey,
		Group:  groupName,
		Start:  "-",
		End:    "+",
		Count:  10, // Process up to 10 messages per check
	}).Result()

	if err != nil {
		log.Printf("Error checking for pending messages: %v", err)
		return
	}

	if len(pendingResult) == 0 {
		log.Println("No pending messages found. âœ…")
		return
	}

	log.Printf("Found %d pending messages. Attempting to claim...\n", len(pendingResult))

	// Collect the IDs of the pending messages
	var messageIDs []string
	for _, p := range pendingResult {
		messageIDs = append(messageIDs, p.ID)
	}

	// 2. Claim the messages that have been idle for at least 10 seconds.
	// The MinIdle duration is crucial to prevent this checker from stealing messages
	// that a normal consumer is actively processing.
	claimResult, err := rdb.XClaim(ctx, &redis.XClaimArgs{
		Stream:   streamKey,
		Group:    groupName,
		Consumer: checkerConsumerName,
		MinIdle:  10 * time.Second, // Only claim messages idle for more than 10s
		Messages: messageIDs,
	}).Result()

	if err != nil {
		// redis.Nil means no messages were claimed (e.g., they weren't idle long enough)
		if err == redis.Nil {
			log.Println("No messages were old enough to be claimed.")
			return
		}
		log.Printf("Error claiming messages: %v", err)
		return
	}

	if len(claimResult) == 0 {
		log.Println("Although pending messages exist, none were idle long enough to be claimed.")
		return
	}

	// 3. Process and Acknowledge the claimed messages
	log.Printf("Successfully claimed %d messages. Processing now...\n", len(claimResult))
	for _, msg := range claimResult {
		log.Printf("Processing claimed message ID: %s, Data: %v", msg.ID, msg.Values)

		// Your actual business logic to process the message goes here.
		// For example, update a database, call an API, etc.
		time.Sleep(500 * time.Millisecond) // Simulate work

		// 4. Acknowledge the message so it's removed from the pending list
		ackResult, err := rdb.XAck(ctx, streamKey, groupName, msg.ID).Result()
		if err != nil {
			log.Printf("Failed to ACK message %s: %v", msg.ID, err)
		} else {
			log.Printf("Successfully processed and ACKed message %s (ACK result: %d).", msg.ID, ackResult)
		}
	}
}
